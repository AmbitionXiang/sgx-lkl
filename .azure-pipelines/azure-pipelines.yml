trigger:
  - 'master'

pr:
  branches:
    include:
    - '*'  # must quote since "*" is a YAML reserved character; we want a string

# A variable group must be defined in Library section with name "SGX-Vars"
variables:
  - group: SGX-Vars
  - name: SGXLKL_ROOT
    value: $(Build.SourcesDirectory)

pool:
  name: "sgx-vms-2"

jobs:  
- job: Build
  displayName: Build
  strategy:
    matrix:
      debug:
        is_debug: 'true'
        use_docker: 'false'
        run_ltp1: 'false'
        run_ltp2: 'false'
      nondebug:
        is_debug: 'false'
        use_docker: 'false'
        run_ltp1: 'false'
        run_ltp2: 'false'
      debug_docker:
        is_debug: 'true'
        use_docker: 'true'
        run_ltp1: 'false'
        run_ltp2: 'false'
      debug_ltp1:
        is_debug: 'true'
        use_docker: 'false'
        run_ltp1: 'true'
        run_ltp2: 'false'
      debug_ltp2:
        is_debug: 'true'
        use_docker: 'false'
        run_ltp1: 'false'
        run_ltp2: 'true'

  steps:
    - checkout: self
      submodules: false
      clean: true

    - task: InstallSSHKey@0
      displayName: "Install an SSH key"
      inputs:
        knownHostsEntry: "*"
        # Public key of 'github_ssh_private_key' (mentioned below) must be declared as variable name in 'SGX-Vars' variable group.
        # Variable Name - GitHubPublicKey
        # Variable Value - <your public key data in string format>
        sshPublicKey: "$(GitHubPublicKey)"
        # A github private key must be uploaded to "Secure files" Section in Azure Pipelines.
        # This key must have read access to private repositories.
        # Once uploaded to secure files, you can rename it to below name.
        sshKeySecureFile: "github_ssh_private_key"

    - task: Bash@3
      displayName: "Checkout Submodules"
      inputs:
        targetType: "FilePath"
        filePath: ".azure-pipelines/scripts/checkout_submodules.sh"

    - task: Bash@3
      displayName: "Install Openenclave"
      inputs:
        targetType: "FilePath"
        filePath: ".azure-pipelines/scripts/install_openenclave.sh"

    - task: Bash@3
      displayName: Cleanup untagged Docker images
      condition: and(succeeded(), eq(variables['use_docker'], 'true'))
      inputs:
        targetType: "FilePath"
        filePath: ".azure-pipelines/scripts/cleanup_docker_images.sh"

    - task: Bash@3
      displayName: Compile and Build
      condition: and(succeeded(), eq(variables['use_docker'], 'false'))
      inputs:
        targetType: "FilePath"
        filePath: ".azure-pipelines/scripts/build.sh"
      env:
        is_debug: "$(is_debug)"

    - task: Bash@3
      displayName: Compile and Build via Docker
      condition: and(succeeded(), eq(variables['use_docker'], 'true'))
      inputs:
        targetType: "FilePath"
        filePath: ".azure-pipelines/scripts/build_docker.sh"
      env:
        is_debug: "$(is_debug)"

    - task: Bash@3
      displayName: "Execute non-LTP Tests"
      condition: and(succeeded(), eq(variables['use_docker'], 'false'), eq(variables['run_ltp1'], 'false'), eq(variables['run_ltp2'], 'false'))
      inputs:
        targetType: "FilePath"
        filePath: ".azure-pipelines/scripts/test_runner.sh"
      env:
        is_debug: "$(is_debug)"

    - task: Bash@3
      displayName: "Execute LTP tests - batch 1"
      condition: and(succeeded(), eq(variables['run_ltp1'], 'true'))
      inputs:
        targetType: "FilePath"
        filePath: ".azure-pipelines/scripts/test_runner.sh"
        arguments: "ltp1"
      env:
        is_debug: "$(is_debug)"

    - task: Bash@3
      displayName: "Execute LTP tests - batch 2"
      condition: and(succeeded(), eq(variables['run_ltp2'], 'true'))
      inputs:
        targetType: "FilePath"
        filePath: ".azure-pipelines/scripts/test_runner.sh"
        arguments: "ltp2"
      env:
        is_debug: "$(is_debug)"

    - task: PublishTestResults@2
      displayName: "Publish Test Results *.xml"
      condition: always()
      inputs:
        testResultsFormat: "JUnit"
        testResultsFiles: "report/*-junit.xml"
        mergeTestResults: true
        failTaskOnFailedTests: true

    - task: PublishBuildArtifacts@1
      displayName: "Archive Logs"
      condition: always()
      inputs:
        pathtoPublish: "report"
        artifactName: logs

    - task: PublishBuildArtifacts@1
      displayName: "Publish Build Artifacts"
      # If you want to publish the 'build' directory after successful make,
      # Then start the build with variable -
      # Name = create_drop
      # Value = true
      condition: and(succeeded(), eq(variables['create_drop'], 'true'))
      inputs:
        pathtoPublish: "build"
        artifactName: drop
